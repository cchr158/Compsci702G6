package GaleShapleV1_1;

/*
 * Author: Callan Christophersen
 * UPI: cchr158
 * 
 * This is an implementation of the Gale-Shapley algorithm for finding a stable maximum matching in a complete bipartite graph.
 */

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Collection;
import java.util.LinkedList;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class Matching {
	public static LinkedList<Blue> blues = new LinkedList<Blue>();
	private Pink[] pinks;

	private class Blue {
		private Collection<Pink> preferanceList = new LinkedList<Pink>();
		private Pink myPink;
		private String id;

		Pink getMyWomen() {
			return this.myPink;
		}

		private void setMyPink(Pink w) {
			this.myPink = w;
		}

		Collection<Pink> getPreferanceList() {
			return this.preferanceList;
		}

		public Blue(String id, String prefList) {
			this.myPink = null;
			this.id = id;
			setPref(prefList);
		}

		private void setPref(String prefList) {
			String[] pinkIDs = prefList.split(",");
			for (int i = 0; i < pinkIDs.length; i++) {
				int j = 0;
				while (!pinks[j].id.equals(pinkIDs[i]))
					j++;
				this.preferanceList.add(pinks[j]);
			}
			// String temp = "";
			// int[] tempList = new int[pinks.length];
			// int j = 0;
			// for (int i = 0; i < string.length(); i++) {
			// if (string.charAt(i) != ' ' && i == string.length() - 1) {
			// temp += string.charAt(i);
			// tempList[j++] = Integer.parseInt(temp);
			// } else if (string.charAt(i) != ' ') {
			// temp += string.charAt(i);
			// } else {
			// tempList[j++] = Integer.parseInt(temp);
			// temp = "";
			// }
			// }
			// for (int i = 0; i < tempList.length; i++) {
			// this.preferanceList.add(gs.getPinks()[tempList[i] - 1]);
			// }
		}
	}

	private class Pink {
		private Blue myBlue;
		private Blue[] preferanceList;
		private Matching gs;
		private String id;

		String getID() {
			return this.id;
		}

		Blue getMyMan() {
			return this.myBlue;
		}

		// returns true is m comes before myBlue in the preference list
		boolean compareToMyBlue(Blue m) {
			for (int i = 0; i < this.preferanceList.length; i++) {
				if (this.preferanceList[i].equals(this.myBlue)) {
					return false;
				}
				if (this.preferanceList[i].equals(m)) {
					return true;
				}
			}
			return false;
		}

		private void setMyBlue(Blue m) {
			this.myBlue = m;
			m.setMyPink(this);
		}

		public Pink(int numberOfMen, Matching gs, String i) {
			this.preferanceList = new Blue[numberOfMen];
			this.myBlue = null;
			this.gs = gs;
			this.id = i;
		}

		private void setPreferances(String prefList) {
			String[] blueIDs = prefList.split(",");
			for (int i = 0; i < blueIDs.length; i++) {
				int j = 0;
				while (!(blues.get(j).id.equals(blueIDs[i])))
					j++;
				this.preferanceList[i] = blues.get(j);
			}
			// String temp = "";
			// int[] tempList = new int[this.preferanceList.length];
			// int j = 0;
			// for (int i = 0; i < string.length(); i++) {
			// if (i == string.length() - 1 && string.charAt(i) != ' ') {
			// temp += string.charAt(i);
			// tempList[j++] = Integer.parseInt(temp);
			// } else if (string.charAt(i) != ' ') {
			// temp += string.charAt(i);
			// } else {
			// tempList[j++] = Integer.parseInt(temp);
			// temp = "";
			// }
			// }
			// Blue[] pL = gs.getBlues().toArray(new
			// Blue[this.preferanceList.length]);
			// for (int i = 0; i < tempList.length; i++) {
			// this.preferanceList[i] = pL[tempList[i] - 1];
			// }
		}

		private boolean isFree() {
			return this.myBlue == null;
		}
	}

	Pink[] getPinks() {
		return pinks;
	}

	Collection<Blue> getBlues() {
		return this.blues;
	}

	private void GaleShapleyAlg() {
		Collection<Blue> blues = new LinkedList<Blue>(this.blues);
		Blue m;
		Pink w;
		while (!blues.isEmpty()) {
			m = ((LinkedList<Blue>) blues).poll();
			w = (Pink) ((LinkedList<Pink>) m.getPreferanceList()).poll();
			if (w.isFree()) {
				w.setMyBlue(m);
			} else {
				if (w.compareToMyBlue(m)) {
					blues.add(w.getMyMan());
					w.setMyBlue(m);
				} else {
					blues.add(m);
				}
			}
		}
	}

	private void printMatching() {
		for (Blue m : this.blues) {
			System.out.println(m.getMyWomen().getID());
		}
	}

	// returns true if s contains white space.
	// private static boolean checkForWhiteSpace(String s) {
	// Pattern p = Pattern.compile("\\s");
	// Matcher m = p.matcher(s);
	// return m.find();
	// }
	public Matching(LinkedList<String> b, LinkedList<String> p) {
		setupPinks(p);
		setupBlues(b);
		setPinksPrefs(p);
		// int i = 0;
		// pinks = new Pink[numberOfPairs];
		// for (; i < numberOfPairs; i++) {
		// pinks[i] = new Pink(numberOfPairs, this, );
		// }
		// for (i = 0; i < numberOfPairs; i++) {
		// blues.add(new Blue(strs[i], this));
		// }
		// for (int j = 0; j < numberOfPairs; j++) {
		// pinks[j].setPreferances(strs[j + i]);
		// }
	}

	private void setPinksPrefs(LinkedList<String> p) {
		for (int i = 0, j = 1; i < pinks.length && j < p.size();) {
			pinks[i].setPreferances(p.get(j));
			i++;
			j += 2;
		}

	}

	private void setupBlues(LinkedList<String> b) {
		for (int i = 0; i < b.size(); i += 2) {
			blues.add(new Blue(b.get(i), b.get(i+1)));
		}
	}

	private void setupPinks(LinkedList<String> p) {
		pinks = new Pink[p.size() / 2];
		int name = 0;
		for (int i = 0; i < p.size() / 2; i++) {
			pinks[i] = new Pink(p.size() / 2, this, p.get(name));
			name += 2;
		}
	}

	// p = ["name","preferance list","name","preferance list",...], b =
	// ["name","preferance list","name","preferance list",...]
	public static void GS(LinkedList<String> b, LinkedList<String> p) {
		b = clearWhiteSpace(b);
		p = clearWhiteSpace(p);
		Matching gs = new Matching(b, p);
		gs.GaleShapleyAlg();
		gs.printMatching();

	}

	private static LinkedList<String> clearWhiteSpace(LinkedList<String> l) {
		String[] lArray = l.toArray(new String[l.size()]);
		l = new LinkedList<String>();
		for (int i = 0; i < lArray.length; i++) {
			char[] c = lArray[i].toCharArray();
			for (int j = 0; j < c.length; j++) {
				if (c[j] == ' ')
					c[j] = '\0';
			}
			String s="";
			for(int j=0; j<c.length; j++){
				s +=c[j];
			}
			//System.out.println(s);
			l.add(s);
		}
		return l;

	}
	
	public static void main(String[] args){
		LinkedList<String> bs = new LinkedList<String>();
		bs.add("A");
		bs.add("3,2,1");
		bs.add("B");
		bs.add("3,2,1");
		bs.add("C");
		bs.add("3,2,1");
		LinkedList<String> ps = new LinkedList<String>();
		ps.add("1");
		ps.add("A,B,C");
		ps.add("2");
		ps.add("A,B,C");
		ps.add("3");
		ps.add("A,B,C");
		Matching.GS(bs, ps);
	}

}